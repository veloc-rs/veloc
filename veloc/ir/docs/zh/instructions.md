# Veloc IR 指令系统

## 概述

Veloc IR（Intermediate Representation）是一种面向栈式虚拟机和寄存器分配的底层中间表示。它采用 SSA（Static Single Assignment）形式，支持多种数据类型和操作。

---

## 类型系统

| 类型 | 描述 | 大小（字节）|
|------|------|------------|
| `I8`, `I16`, `I32`, `I64` | 有符号整数 | 1, 2, 4, 8 |
| `F32`, `F64` | IEEE 754 浮点数 | 4, 8 |
| `Bool` | 布尔值 | 1 |
| `Ptr` | 指针类型 | 8 |
| `Void` | 无返回值 | 0 |

---

## 实体标识符

| 类型 | 用途 |
|------|------|
| `Inst` | 指令标识符 |
| `Value` | SSA 值标识符 |
| `Block` | 基本块标识符 |
| `StackSlot` | 栈槽标识符 |
| `FuncId` | 函数标识符 |
| `SigId` | 函数签名标识符 |
| `BlockCall` | 块调用（带参数）|
| `JumpTable` | 跳转表标识符 |

---

## 指令列表

### 1. 一元运算指令

#### `Unary`
| 属性 | 说明 |
|------|------|
| **操作数** | `opcode: Opcode`, `arg: Value` |
| **返回类型** | `ty`（由指令数据指定）|
| **描述** | 一元运算：取反、绝对值、类型转换、位计数等 |

**约束条件：**
- `arg` 的类型必须与 `opcode` 期望的输入类型匹配
- 对于整数扩展/截断操作，`ty` 必须是整数类型
- 对于浮点运算，`arg` 必须是浮点类型

**支持的操作码：**
- 算术: `Ineg`, `Fneg`, `Abs`, `Sqrt`, `Ceil`, `Floor`
- 转换: `ExtendS/U`, `Wrap`, `TruncS/U`, `ConvertS/U`, `Demote`, `Promote`, `Reinterpret`
- 位操作: `Clz`（前导零计数）, `Ctz`（尾随零计数）, `Popcnt`（1位计数）, `Eqz`（是否为零）

---

### 2. 二元运算指令

#### `Binary`
| 属性 | 说明 |
|------|------|
| **操作数** | `opcode: Opcode`, `args: [Value; 2]` |
| **返回类型** | `ty`（由指令数据指定）|
| **描述** | 二元运算：算术、逻辑、位运算 |

**约束条件：**
- 两个操作数的类型必须相同
- 操作数类型必须与 `opcode` 兼容（整数操作码需要整数类型，浮点操作码需要浮点类型）
- 对于有符号/无符号区分（如 `DivS` vs `DivU`），操作数类型必须是整数

**支持的操作码：**
- 整数: `Iadd`, `Isub`, `Imul`, `DivS/U`, `RemS/U`, `And`, `Or`, `Xor`, `Shl`, `ShrS/U`, `Rotl`, `Rotr`
- 浮点: `Fadd`, `Fsub`, `Fmul`, `Fdiv`, `Min`, `Max`, `Copysign`

---

### 3. 内存访问指令

#### `Load`
| 属性 | 说明 |
|------|------|
| **操作数** | `ptr: Value`, `offset: u32`, `flags: MemFlags` |
| **返回类型** | `ty` |
| **描述** | 从内存地址 `ptr + offset` 加载类型为 `ty` 的值 |

**约束条件：**
- `ptr` 必须是 `Ptr` 类型
- `ty` 必须是 `I8`, `I16`, `I32`, `I64`, `F32`, `F64` 之一
- `offset` 必须保证最终地址对齐到 `ty` 的自然对齐边界（除非 `flags` 指定了非对齐访问）
- 加载地址必须在有效的内存范围内

---

#### `Store`
| 属性 | 说明 |
|------|------|
| **操作数** | `ptr: Value`, `value: Value`, `offset: u32`, `flags: MemFlags` |
| **返回类型** | `Void`（无返回值）|
| **描述** | 将 `value` 存储到内存地址 `ptr + offset` |

**约束条件：**
- `ptr` 必须是 `Ptr` 类型
- `value` 的类型必须是 `I8`, `I16`, `I32`, `I64`, `F32`, `F64` 之一
- `offset` 必须保证最终地址对齐到 `value` 类型的自然对齐边界（除非 `flags` 指定了非对齐访问）
- 存储地址必须在有效的可写内存范围内

---

#### `StackLoad`
| 属性 | 说明 |
|------|------|
| **操作数** | `slot: StackSlot`, `offset: u32` |
| **返回类型** | `ty` |
| **描述** | 从栈槽加载值 |

**约束条件：**
- `slot` 必须是当前函数声明的有效栈槽
- `offset + sizeof(ty)` 必须在栈槽大小范围内
- `ty` 支持 `I8`, `I16`, `I32`, `I64`, `F32`, `F64`

---

#### `StackStore`
| 属性 | 说明 |
|------|------|
| **操作数** | `slot: StackSlot`, `value: Value`, `offset: u32` |
| **返回类型** | `Void` |
| **描述** | 存储值到栈槽 |

**约束条件：**
- `slot` 必须是当前函数声明的有效栈槽
- `offset + sizeof(value)` 必须在栈槽大小范围内

---

#### `StackAddr`
| 属性 | 说明 |
|------|------|
| **操作数** | `slot: StackSlot`, `offset: u32` |
| **返回类型** | `Ptr` |
| **描述** | 获取栈槽的地址（`&slot[offset]`） |

**约束条件：**
- `slot` 必须是当前函数声明的有效栈槽

---

### 4. 常量指令

#### `Iconst`
| 属性 | 说明 |
|------|------|
| **操作数** | `value: i64` |
| **返回类型** | `ty`（必须是整数类型 `I8`, `I16`, `I32`, `I64`） |
| **描述** | 整数常量 |

**约束条件：**
- `ty` 必须是整数类型
- `value` 必须在 `ty` 类型的表示范围内（如果 `ty` 是 `I8`，则 `value` 必须在 -128~127 之间）

---

#### `Fconst`
| 属性 | 说明 |
|------|------|
| **操作数** | `value: u64`（位表示） |
| **返回类型** | `ty`（必须是 `F32` 或 `F64`） |
| **描述** | 浮点常量 |

**约束条件：**
- `ty` 必须是 `F32` 或 `F64`
- 对于 `F32`，只使用 `value` 的低 32 位

---

#### `Bconst`
| 属性 | 说明 |
|------|------|
| **操作数** | `value: bool` |
| **返回类型** | `Bool` |
| **描述** | 布尔常量 |

---

### 5. 控制流指令

#### `Jump`
| 属性 | 说明 |
|------|------|
| **操作数** | `dest: BlockCall` |
| **返回类型** | `Void` |
| **描述** | 无条件跳转到目标基本块 |

**约束条件：**
- `dest` 必须是当前函数内的有效基本块
- `dest` 携带的参数类型必须与目标块的参数类型匹配（数量和类型）
- 必须是基本块的最后一个指令

---

#### `Br`（条件分支）
| 属性 | 说明 |
|------|------|
| **操作数** | `condition: Value`, `then_dest: BlockCall`, `else_dest: BlockCall` |
| **返回类型** | `Void` |
| **描述** | 如果 `condition` 为真，跳转到 `then_dest`，否则跳转到 `else_dest` |

**约束条件：**
- `condition` 必须是 `Bool` 类型
- `then_dest` 和 `else_dest` 必须是当前函数内的有效基本块
- 两个目标块的参数类型必须与提供的参数匹配
- 必须是基本块的最后一个指令

---

#### `BrTable`（间接跳转表）
| 属性 | 说明 |
|------|------|
| **操作数** | `index: Value`, `table: JumpTable` |
| **返回类型** | `Void` |
| **描述** | 根据 `index` 选择跳转目标（类似 switch） |

**约束条件：**
- `index` 必须是整数类型（通常 `I32`）
- `table` 包含默认目标和所有 case 目标
- 如果 `index` 越界，跳转到默认目标
- 所有目标块必须有兼容的参数类型
- 必须是基本块的最后一个指令

---

#### `Return`
| 属性 | 说明 |
|------|------|
| **操作数** | `value: Option<Value>` |
| **返回类型** | `Void` |
| **描述** | 函数返回，可选返回值 |

**约束条件：**
- 如果函数返回类型不是 `Void`，`value` 必须存在且类型匹配函数签名
- 如果函数返回类型是 `Void`，`value` 必须是 `None`
- 必须是基本块的最后一个指令

---

#### `Unreachable`
| 属性 | 说明 |
|------|------|
| **操作数** | 无 |
| **返回类型** | `Void` |
| **描述** | 标记不可达代码 |

**约束条件：**
- 必须是基本块的最后一个指令
- 在此之后的代码不应被执行到

---

### 6. 比较与选择指令

#### `IntCompare`（整数比较）
| 属性 | 说明 |
|------|------|
| **操作数** | `kind: IntCC`, `args: [Value; 2]` |
| **返回类型** | `Bool` |
| **描述** | 比较两个整数 |

**约束条件：**
- 两个操作数必须是相同的整数类型
- `kind` 指定比较方式：`Eq`, `Ne`, `LtS`, `LtU`, `LeS`, `LeU`, `GtS`, `GtU`, `GeS`, `GeU`
- 注意：有符号和无符号比较（`S` vs `U` 后缀）

---

#### `FloatCompare`（浮点比较）
| 属性 | 说明 |
|------|------|
| **操作数** | `kind: FloatCC`, `args: [Value; 2]` |
| **返回类型** | `Bool` |
| **描述** | 比较两个浮点数 |

**约束条件：**
- 两个操作数必须是相同的浮点类型（`F32` 或 `F64`）
- `kind` 指定比较方式：`Eq`, `Ne`, `Lt`, `Le`, `Gt`, `Ge`
- 注意：IEEE 754 特殊值的处理（NaN 比较总是返回 false）

---

#### `Select`（条件选择）
| 属性 | 说明 |
|------|------|
| **操作数** | `condition: Value`, `then_val: Value`, `else_val: Value` |
| **返回类型** | `ty`（与 `then_val`/`else_val` 相同） |
| **描述** | 如果 `condition` 为真返回 `then_val`，否则返回 `else_val` |

**约束条件：**
- `condition` 必须是 `Bool` 类型
- `then_val` 和 `else_val` 必须是相同类型
- `ty` 必须与 `then_val`/`else_val` 的类型一致

---

### 7. 函数调用指令

#### `Call`（直接调用）
| 属性 | 说明 |
|------|------|
| **操作数** | `func_id: FuncId`, `args: ValueList` |
| **返回类型** | 由被调用函数的签名决定 |
| **描述** | 调用指定函数 |

**约束条件：**
- `func_id` 必须是模块中声明的有效函数
- `args` 的数量和类型必须与被调用函数的签名匹配
- 返回类型由函数签名决定

---

#### `CallIndirect`（间接调用）
| 属性 | 说明 |
|------|------|
| **操作数** | `ptr: Value`, `args: ValueList`, `sig_id: SigId` |
| **返回类型** | 由 `sig_id` 指定的签名决定 |
| **描述** | 通过函数指针调用 |

**约束条件：**
- `ptr` 必须是 `Ptr` 类型
- `sig_id` 必须是模块中声明的有效签名
- `args` 的数量和类型必须与签名匹配
- 运行时 `ptr` 必须指向与签名兼容的函数

---

#### `CallIntrinsic`（内建函数调用）
| 属性 | 说明 |
|------|------|
| **操作数** | `intrinsic: Intrinsic`, `args: ValueList`, `sig_id: SigId` |
| **返回类型** | 由 `sig_id` 指定的签名决定 |
| **描述** | 调用编译器内建的特殊函数 |

**约束条件：**
- `intrinsic` 必须是有效的内建函数标识符
- `sig_id` 必须与内建函数的期望签名匹配
- 不同内建函数有特定的参数要求（见下方）

**内建函数列表：**

| 内建函数 | 参数 | 返回类型 | 描述 |
|---------|------|---------|------|
| `SIN_F32/F64` | `x: F32/F64` | `F32/F64` | 正弦函数 |
| `COS_F32/F64` | `x: F32/F64` | `F32/F64` | 余弦函数 |
| `POW_F32/F64` | `base, exp: F32/F64` | `F32/F64` | 幂函数 |
| `EXP_F32/F64` | `x: F32/F64` | `F32/F64` | 自然指数 |
| `LOG_F32/F64` | `x: F32/F64` | `F32/F64` | 自然对数 |
| `LOG2_F32/F64` | `x: F32/F64` | `F32/F64` | 以 2 为底的对数 |
| `LOG10_F32/F64` | `x: F32/F64` | `F32/F64` | 以 10 为底的对数 |
| `MEMCPY` | `dest: Ptr`, `src: Ptr`, `len: I64` | `Void` | 内存拷贝 |
| `MEMMOVE` | `dest: Ptr`, `src: Ptr`, `len: I64` | `Void` | 内存移动（允许重叠） |
| `MEMSET` | `dest: Ptr`, `val: I32`, `len: I64` | `Void` | 内存填充 |
| `MEMCMP` | `a: Ptr`, `b: Ptr`, `len: I64` | `I32` | 内存比较 |
| `FENCE` | 无 | `Void` | 全内存屏障 |
| `ASSUME` | `cond: Bool` | `Void` | 优化提示：条件为真 |
| `EXPECT` | `val: T`, `expected: T` | `T` | 优化提示：值的期望值 |
| `TRAP` | 无 | `Void` | 触发陷阱/异常 |

---

### 8. 指针操作指令

#### `IntToPtr`
| 属性 | 说明 |
|------|------|
| **操作数** | `arg: Value` |
| **返回类型** | `Ptr` |
| **描述** | 将整数转换为指针 |

**约束条件：**
- `arg` 必须是整数类型（通常 `I64`）
- 转换的整数值应该是有效的指针地址

---

#### `PtrToInt`
| 属性 | 说明 |
|------|------|
| **操作数** | `arg: Value` |
| **返回类型** | `ty`（必须是整数类型） |
| **描述** | 将指针转换为整数 |

**约束条件：**
- `arg` 必须是 `Ptr` 类型
- `ty` 必须是整数类型（通常 `I64`）

---

#### `PtrOffset`
| 属性 | 说明 |
|------|------|
| **操作数** | `ptr: Value`, `offset: i32` |
| **返回类型** | `Ptr` |
| **描述** | 指针偏移（字节为单位）：`ptr + offset` |

**约束条件：**
- `ptr` 必须是 `Ptr` 类型
- `offset` 以字节为单位，可以是负数

---

#### `PtrIndex`
| 属性 | 说明 |
|------|------|
| **操作数** | `ptr: Value`, `index: Value`, `scale: u32`, `offset: i32` |
| **返回类型** | `Ptr` |
| **描述** | 指针索引计算：`ptr + index * scale + offset` |

**约束条件：**
- `ptr` 必须是 `Ptr` 类型
- `index` 必须是整数类型
- `scale` 通常是元素大小（如 4 表示 `I32` 数组）
- `offset` 以字节为单位，可以是负数

---

### 9. 其他指令

#### `Nop`
| 属性 | 说明 |
|------|------|
| **操作数** | 无 |
| **返回类型** | `Void` |
| **描述** | 空操作，无效果 |

---

## 指令属性

### `is_terminator` - 终止指令
以下指令必须是基本块的最后一个指令：
- `Jump`
- `Br`
- `BrTable`
- `Return`
- `Unreachable`

### `has_side_effects` - 副作用
具有副作用的指令（不能被随意删除或重排序）：
- `Store`, `StackStore` - 修改内存
- `Call`, `CallIndirect`, `CallIntrinsic` - 可能产生任意副作用
- `Return` - 控制流转移
- `Jump`, `Br`, `BrTable` - 控制流转移
- `Unreachable` - 控制流标记

### `visit_operands`
遍历指令使用的所有 `Value`，用于：
- 活跃变量分析
- 寄存器分配
- SSA 解构

---

## 基本块结构

每个基本块：
1. 以一组参数开始（可以为空）
2. 包含零个或多个非终止指令
3. 以恰好一个终止指令结束

**约束：**
- 参数在块内是 SSA 值
- 跳转时必须提供与目标块参数匹配的参数
- 控制流图中，块的前驱必须与其参数定义一致
